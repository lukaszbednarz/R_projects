{
    "collab_server" : "",
    "contents" : "# printTransactions.r\n# \n# Function for HackerRank https://www.hackerrank.com/challenges/stockprediction challenge\n# last updated: March 24 2016 Lukasz Bednarz\n#\n# Functions:\n#\t1. printTransactions  \t\t\ttakes a float m money left, an integer k number of stocks, \n#                             an integer d days left, a string array name of stock names, \n#                             an integer array owned of stocks owned, and an 2d integer \n#                             array prices of stock prices containing k arrays of length 5 \n#                             and print your output.\n#\n\nprintTransactions <-\nfunction(m, k, d , name, owned, prices) {\n  portfolio<-list(\"m\" = m,\n                  \"k\" = k,\n                  \"d\" = d,\n                  \"name\" = name,\n                  \"owned\" = owned,\n                  \"prices\" = prices)\n  \n  #call<- match.call()\n  \n  # read back from storage file\n  if (file.exists('hist_prices.csv')){\n    Data <- read.csv('hist_prices.csv')\n    Data <- rbind(Data, portfolio$prices[,tail(1)])\n    write.csv(Data, 'hist_prices.csv')\n  }\n  else {\n    Data <- data.frame(t(prices))\n    names(Data)<-name\n    rownames(Data) <- c(1:nrow(Data))\n    write.csv(Data, 'hist_prices.csv')\n  }\n  \n\n  portfolio.new<-optimizePortfolio(Data, portfolio)\n  \n  result<-prepareOutput(portfolio, portfolio.new)\n  \n  writeLines(result)\n  \n  result\n}\n\n###################\n# prepareOutput(portfolio.old, portfolio.new)\n###################\n\nprepareOutput <-\nfunction(old_p, new_p) {\n  \n  delta<-new_p$owned - old_p$owned\n  \n  orders<-new_p$name[delta != 0]\n  \n  outp<-paste0(length(orders),\"\\n\",collapse=\"\")\n  \n  for (tick in orders) {\n    cmd<-\"BUY\"\n    if (delta[tick] < 0){\n      cmd<-\"SELL\"\n    }\n    outp<-paste0(outp,paste(tick, cmd, delta[tick] ), \"\\n\", collapse=\"\")\n  }\n  \n  outp\n}\n\noptimizePortfolio <-\nfunction (data, portf) {\n  \n  ### Calculate covariance matrix\n\n  stox.df.logd <- log(data[2:nrow(data),]) - log(data[1:nrow(data)-1,])\n  \n  stox.ret<-colMeans(stox.df.logd)\n  target.ret = max(stox.ret)\n  \n  stox.cov<-cov(stox.df)\n  \n  price.current<-data[nrow(data),]\n  \n  # calculate current portfolio value of holdings\n  w.current <- portfolio$owned*price.current\n  \n  # total portfolio value\n  net.portf <- sum(w.current)\n  \n  w.current <- w.current/(net.portf + portf$m)\n\n  # computing efficient portfolio\n  w <- efficientPortfolio(stox.cov, stox.ret, price.current, net.portf + portf$m, portf$name )\n  \n  #  trades in terms of number of shares\n  delta <- round((w - w.current)*(net.portf+portf$m)/price.current,0)\n  \n  # action\n  \n  portf.new <- portf\n  \n  portf.new$owned <- portf$owned + delta\n  \n  portf.new\n}\n\nefficientPortfolio <-\nfunction(stox.cov, stox.ret, prices, totalValue,stox.names ){\n  \n  library(quadprog)\n  # As there is no shorts\n  # this is QP problem: min(-d' b + 1/2 b' D b) with the constraints A' b >= b_0.\n  # in our case A consist of rules: weights'*returns = alpha_0 weights > = zeros(mx1)\n  # weights'*ones(mx1) = 1\n  # solve.QP(Dmat, dvec, Amat, bvec, meq=0, factorized=FALSE)\n  N_stock<-nrow(stox.cov)\n  \n  risk.prem <- seq(0, 2, 0.1)\n  \n  meq <- 1\n  Dmat <- 2*stox.cov\n  \n  # conditions for equality\n  bvec.eq <- 1\n  Amat.eq <- rep(1, N_stock)\n  \n  \n  bvec.ineq <- rep(0, N_stock)\n  Amat.ineq <- cbind(diag(N_stock),-diag(N_stock))\n  \n  \n  ## conditioning matrix for stock due to granularity and price\n  ## the weights have to be less than weight of max integer number of shares\n  ## that can be used for given portfolio net value\n  for (ii in 1:N_stock) {\n    bvec.ineq <-c(bvec.ineq, -floor(totalValue/prices[ii])*prices[ii]/totalValue)\n  }\n  \n  eff <- matrix(nrow=length(risk.prem), ncol=N_stock+3)\n  colnames(eff)<-c(stox.names,\"Std.Dev\",\"Exp.Return\",\"Sharpe\")\n  \n  sharpe.max <- 0\n  prem.max <- 1\n  loop.max<-1\n  loop <- 1\n  \n  \n  # find approximate efficient portfolio with max sharpe\n  for (ii in 1:length(risk.prem)) {\n  \n    dvec <- stox.ret*risk.prem[ii]\n    Amat <- cbind(Amat.eq, Amat.ineq)\n    bvec <- c(bvec.eq, bvec.ineq)\n  \n    result <- solve.QP(Dmat=Dmat,dvec=dvec,Amat=Amat,bvec=bvec,meq=meq)\n    eff[loop,\"Std.Dev\"] <- sqrt(sum(result$solution *colSums((stox.cov * result$solution))))\n    eff[loop,\"Exp.Return\"] <- as.numeric(result$solution %*% stox.ret)\n    eff[loop,\"Sharpe\"] <- eff[loop,\"Exp.Return\"] / eff[loop,\"Std.Dev\"]\n    eff[loop,1:N_stock] <- result$solution\n    \n    if (eff[loop,\"Sharpe\"] > sharpe.max){\n      sharpe.max<-eff[loop,\"Sharpe\"]\n      prem.max<-risk.prem[ii]\n      loop.max<-ii\n    }\n    # increment loop counter\n    loop <- loop+1\n    \n  }\n\n  w.sharpe <- eff[loop.max,1:N_stock] \n  \n  prices.sorted<-sort(as.numeric(prices), index.return=TRUE, decreasing = TRUE)\n  prices.sorted.ix<-prices.sorted$ix[prices.sorted$x<=totalValue]\n  # vector fixing stock values starting from most expensive\n  # then continuing optimizing portfolio down to least expensive\n  b.eq<-w.sharpe\n  \n  opt <- matrix(nrow=length(prices.sorted.ix), ncol=N_stock+3)\n  colnames(opt)<-c(stox.names,\"Std.Dev\",\"Exp.Return\",\"Sharpe\")\n  loop <-1\n  \n  while (loop < length(prices.sorted.ix)) {\n    ii <- prices.sorted.ix[loop]\n    meq <- meq +1\n    Amat.vec<-rep(0,N_stock)\n    Amat.vec[ii]<-1\n    Amat.eq <-cbind(Amat.eq, Amat.vec)\n    b.eq[ii]<-min(floor(totalValue/prices[ii])*prices[ii]/totalValue,\n                  round(totalValue/prices[ii]*b.eq[ii]))\n    bvec.eq<-c(bvec.eq,b.eq[ii])\n    \n    bvec<-c(bvec.eq,bvec.ineq)\n    Amat<-cbind(Amat.eq, Amat.ineq)\n    \n    result <- solve.QP(Dmat=Dmat,dvec=dvec,Amat=Amat,bvec=bvec,meq=meq)\n    opt[loop,\"Std.Dev\"] <- sqrt(sum(result$solution *colSums((stox.cov * result$solution))))\n    opt[loop,\"Exp.Return\"] <- as.numeric(result$solution %*% stox.ret)\n    opt[loop,\"Sharpe\"] <- eff[loop,\"Exp.Return\"] / eff[loop,\"Std.Dev\"]\n    opt[loop,1:N_stock] <- result$solution\n    \n    # increment loop\n    loop <- loop+1\n  }\n  \n  result$solution\n}\n",
    "created" : 1458862609097.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3083029207",
    "id" : "530598B",
    "lastKnownWriteTime" : 1458959677,
    "last_content_update" : 1458959677967,
    "path" : "~/Lukasz/Learning/HackerRank_R/02_Stock_Predictions/printTransactions.r",
    "project_path" : "printTransactions.r",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}