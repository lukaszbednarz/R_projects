{
    "collab_server" : "",
    "contents" : "# portfolio.r\n# \n# Functions for portfolio analysis\n# to be used in Introduction to Computational Finance & Financial Econometrics\n# last updated: November 7, 2000 by Eric Zivot\n#               Oct 15, 2003 by Tim Hesterberg\n#               November 18, 2003 by Eric Zivot\n#               November 9, 2004 by Eric Zivot\n#\t\t            November 9, 2008 by Eric Zivot\n#               August 11, 2011 by Eric Zivot\n#\n# Functions:\n#\t1. efficient.portfolio\t\t\tcompute minimum variance portfolio\n#\t\t\t\t\t\t\t                subject to target return\n#\t2. globalMin.portfolio\t\t\tcompute global minimum variance portfolio\n#\t3. tangency.portfolio\t\t\t  compute tangency portfolio\n#\t4. efficient.frontier\t\t\t  compute Markowitz bullet\n#\t5. getPortfolio\t\t\t\t\t    create portfolio object\n#\n\ngetPortfolio <-\nfunction(er, cov.mat, weights)\n{\n\t# contruct portfolio object\n\t#\n\t# inputs:\n\t# er\t\t\t\t   N x 1 vector of expected returns\n\t# cov.mat  \t\t N x N covariance matrix of returns\n\t# weights\t\t\t N x 1 vector of portfolio weights\n\t#\n\t# output is portfolio object with the following elements\n\t# call\t\t\t\toriginal function call\n\t# er\t\t\t\t  portfolio expected return\n\t# sd\t\t\t\t  portfolio standard deviation\n\t# weights\t\t\tN x 1 vector of portfolio weights\n\t#\n\tcall <- match.call()\n\t\n\t#\n\t# check for valid inputs\n\t#\n\tasset.names <- names(er)\n\tweights <- as.vector(weights)\n\tnames(weights) = names(er)\n  \ter <- as.vector(er)\t\t\t\t\t# assign names if none exist\n\tif(length(er) != length(weights))\n\t\tstop(\"dimensions of er and weights do not match\")\n \tcov.mat <- as.matrix(cov.mat)\n\tif(length(er) != nrow(cov.mat))\n\t\tstop(\"dimensions of er and cov.mat do not match\")\n\tif(any(diag(chol(cov.mat)) <= 0))\n\t\tstop(\"Covariance matrix not positive definite\")\n\t\t\n\t#\n\t# create portfolio\n\t#\n\ter.port <- crossprod(er,weights)\n\tsd.port <- sqrt(weights %*% cov.mat %*% weights)\n\tans <- list(\"call\" = call,\n\t      \"er\" = as.vector(er.port),\n\t      \"sd\" = as.vector(sd.port),\n\t      \"weights\" = weights) \n\tclass(ans) <- \"portfolio\"\n\tans\n}\n\nefficient.portfolio <-\nfunction(er, cov.mat, target.return)\n{\n  # compute minimum variance portfolio subject to target return\n  #\n  # inputs:\n  # er\t\t\t\t\t    N x 1 vector of expected returns\n  # cov.mat  \t\t\t  N x N covariance matrix of returns\n  # target.return\t  scalar, target expected return\n  #\n  # output is portfolio object with the following elements\n  # call\t\t\t\t    original function call\n  # er\t\t\t\t\t    portfolio expected return\n  # sd\t\t\t\t\t    portfolio standard deviation\n  # weights\t\t\t    N x 1 vector of portfolio weights\n  #\n  call <- match.call()\n\n  #\n  # check for valid inputs\n  #\n  asset.names <- names(er)\n  er <- as.vector(er)\t\t\t\t\t# assign names if none exist\n  cov.mat <- as.matrix(cov.mat)\n  if(length(er) != nrow(cov.mat))\n    stop(\"invalid inputs\")\n  if(any(diag(chol(cov.mat)) <= 0))\n    stop(\"Covariance matrix not positive definite\")\n  # remark: could use generalized inverse if cov.mat is positive semidefinite\n\n  #\n  # compute efficient portfolio\n  #\n  ones <- rep(1, length(er))\n  top <- cbind(2*cov.mat, er, ones)\n  bot <- cbind(rbind(er, ones), matrix(0,2,2))\n  A <- rbind(top, bot)\n  b.target <- as.matrix(c(rep(0, length(er)), target.return, 1))\n  x <- solve(A, b.target)\n  w <- x[1:length(er)]\n  names(w) <- asset.names\n\n  #\n  # compute portfolio expected returns and variance\n  #\n  er.port <- crossprod(er,w)\n  sd.port <- sqrt(w %*% cov.mat %*% w)\n  ans <- list(\"call\" = call,\n\t      \"er\" = as.vector(er.port),\n\t      \"sd\" = as.vector(sd.port),\n\t      \"weights\" = w) \n  class(ans) <- \"portfolio\"\n  ans\n}\n\nglobalMin.portfolio <-\nfunction(er, cov.mat)\n{\n  # Compute global minimum variance portfolio\n  #\n  # inputs:\n  # er\t\t\t\tN x 1 vector of expected returns\n  # cov.mat\t\tN x N return covariance matrix\n  #\n  # output is portfolio object with the following elements\n  # call\t\t\toriginal function call\n  # er\t\t\t\tportfolio expected return\n  # sd\t\t\t\tportfolio standard deviation\n  # weights\t\tN x 1 vector of portfolio weights\n  call <- match.call()\n\n  #\n  # check for valid inputs\n  #\n  asset.names <- names(er)\n  er <- as.vector(er)\t\t\t\t\t# assign names if none exist\n  cov.mat <- as.matrix(cov.mat)\n  if(length(er) != nrow(cov.mat))\n    stop(\"invalid inputs\")\n  if(any(diag(chol(cov.mat)) <= 0))\n    stop(\"Covariance matrix not positive definite\")\n  # remark: could use generalized inverse if cov.mat is positive semi-definite\n\n  #\n  # compute global minimum portfolio\n  #\n  cov.mat.inv <- solve(cov.mat)\n  one.vec <- rep(1,length(er))\n#  w.gmin <- cov.mat.inv %*% one.vec/as.vector(one.vec %*% cov.mat.inv %*% one.vec)\n  w.gmin <- rowSums(cov.mat.inv) / sum(cov.mat.inv)\n  w.gmin <- as.vector(w.gmin)\n  names(w.gmin) <- asset.names\n  er.gmin <- crossprod(w.gmin,er)\n  sd.gmin <- sqrt(t(w.gmin) %*% cov.mat %*% w.gmin)\n  gmin.port <- list(\"call\" = call,\n\t\t    \"er\" = as.vector(er.gmin),\n\t\t    \"sd\" = as.vector(sd.gmin),\n\t\t    \"weights\" = w.gmin)\n  class(gmin.port) <- \"portfolio\"\n  gmin.port\n}\n\n\ntangency.portfolio <- \nfunction(er,cov.mat,risk.free)\n{\n  # compute tangency portfolio\n  #\n  # inputs:\n  # er\t\t\t\t   N x 1 vector of expected returns\n  # cov.mat\t\t   N x N return covariance matrix\n  # risk.free\t\t scalar, risk-free rate\n  #\n  # output is portfolio object with the following elements\n  # call\t\t\t  captures function call\n  # er\t\t\t\t  portfolio expected return\n  # sd\t\t\t\t  portfolio standard deviation\n  # weights\t\t N x 1 vector of portfolio weights\n  call <- match.call()\n\n  #\n  # check for valid inputs\n  #\n  asset.names <- names(er)\n  if(risk.free < 0)\n    stop(\"Risk-free rate must be positive\")\n  er <- as.vector(er)\n  cov.mat <- as.matrix(cov.mat)\n  if(length(er) != nrow(cov.mat))\n    stop(\"invalid inputs\")\n  if(any(diag(chol(cov.mat)) <= 0))\n    stop(\"Covariance matrix not positive definite\")\n  # remark: could use generalized inverse if cov.mat is positive semi-definite\n\n  #\n  # compute global minimum variance portfolio\n  #\n  gmin.port <- globalMin.portfolio(er,cov.mat)\n  if(gmin.port$er < risk.free)\n    stop(\"Risk-free rate greater than avg return on global minimum variance portfolio\")\n\n  # \n  # compute tangency portfolio\n  #\n  cov.mat.inv <- solve(cov.mat)\n  w.t <- cov.mat.inv %*% (er - risk.free) # tangency portfolio\n  w.t <- as.vector(w.t/sum(w.t))\t# normalize weights\n  names(w.t) <- asset.names\n  er.t <- crossprod(w.t,er)\n  sd.t <- sqrt(t(w.t) %*% cov.mat %*% w.t)\n  tan.port <- list(\"call\" = call,\n\t\t   \"er\" = as.vector(er.t),\n\t\t   \"sd\" = as.vector(sd.t),\n\t\t   \"weights\" = w.t)\n  class(tan.port) <- \"portfolio\"\n  tan.port\n}\n\nefficient.frontier <- \nfunction(er, cov.mat, nport=20, alpha.min=-0.5, alpha.max=1.5)\n{\n  # Compute efficient frontier with no short-sales constraints\n  #\n  # inputs:\n  # er\t\t\t  N x 1 vector of expected returns\n  # cov.mat\t  N x N return covariance matrix\n  # nport\t\t  scalar, number of efficient portfolios to compute\n  #\n  # output is a Markowitz object with the following elements\n  # call\t\t  captures function call\n  # er\t\t\t  nport x 1 vector of expected returns on efficient porfolios\n  # sd\t\t\t  nport x 1 vector of std deviations on efficient portfolios\n  # weights \tnport x N matrix of weights on efficient portfolios \n  call <- match.call()\n\n  #\n  # check for valid inputs\n  #\n  asset.names <- names(er)\n  er <- as.vector(er)\n  cov.mat <- as.matrix(cov.mat)\n  if(length(er) != nrow(cov.mat))\n    stop(\"invalid inputs\")\n  if(any(diag(chol(cov.mat)) <= 0))\n    stop(\"Covariance matrix not positive definite\")\n\n  #\n  # create portfolio names\n  #\n  port.names <- rep(\"port\",nport)\n  ns <- seq(1,nport)\n  port.names <- paste(port.names,ns)\n\n  #\n  # compute global minimum variance portfolio\n  #\n  cov.mat.inv <- solve(cov.mat)\n  one.vec <- rep(1,length(er))\n  port.gmin <- globalMin.portfolio(er,cov.mat)\n  w.gmin <- port.gmin$weights\n\n  #\n  # compute efficient frontier as convex combinations of two efficient portfolios\n  # 1st efficient port: global min var portfolio\n  # 2nd efficient port: min var port with ER = max of ER for all assets\n  #\n  er.max <- max(er)\n  port.max <- efficient.portfolio(er,cov.mat,er.max)\n  w.max <- port.max$weights    \n  a <- seq(from=alpha.min,to=alpha.max,length=nport)\t\t\t# convex combinations\n  we.mat <- a %o% w.gmin + (1-a) %o% w.max\t# rows are efficient portfolios\n  er.e <- we.mat %*% er\t\t\t\t\t\t\t# expected returns of efficient portfolios\n  er.e <- as.vector(er.e)\n  names(er.e) <- port.names\n  cov.e <- we.mat %*% cov.mat %*% t(we.mat) # cov mat of efficient portfolios\n  sd.e <- sqrt(diag(cov.e))\t\t\t\t\t# std devs of efficient portfolios\n  sd.e <- as.vector(sd.e)\n  names(sd.e) <- port.names\n  dimnames(we.mat) <- list(port.names,asset.names)\n\n  # \n  # summarize results\n  #\n  ans <- list(\"call\" = call,\n\t      \"er\" = er.e,\n\t      \"sd\" = sd.e,\n\t      \"weights\" = we.mat)\n  class(ans) <- \"Markowitz\"\n  ans\n}\n\n#\n# print method for portfolio object\nprint.portfolio <- function(x, ...)\n{\n  cat(\"Call:\\n\")\n  print(x$call, ...)\n  cat(\"\\nPortfolio expected return:    \", format(x$er, ...), \"\\n\")\n  cat(\"Portfolio standard deviation: \", format(x$sd, ...), \"\\n\")\n  cat(\"Portfolio weights:\\n\")\n  print(round(x$weights,4), ...)\n  invisible(x)\n}\n\n#\n# summary method for portfolio object\nsummary.portfolio <- function(object, risk.free=NULL, ...)\n# risk.free\t\t\trisk-free rate. If not null then\n#\t\t\t\tcompute and print Sharpe ratio\n# \n{\n  cat(\"Call:\\n\")\n  print(object$call)\n  cat(\"\\nPortfolio expected return:    \", format(object$er, ...), \"\\n\")\n  cat(  \"Portfolio standard deviation: \", format(object$sd, ...), \"\\n\")\n  if(!is.null(risk.free)) {\n    SharpeRatio <- (object$er - risk.free)/object$sd\n    cat(\"Portfolio Sharpe Ratio:       \", format(SharpeRatio), \"\\n\")\n  }\n  cat(\"Portfolio weights:\\n\")\n  print(round(object$weights,4), ...)\n  invisible(object)\n}\n# hard-coded 4 digits; prefer to let user control, via ... or other argument\n\n#\n# plot method for portfolio object\nplot.portfolio <- function(object, ...)\n{\n  asset.names <- names(object$weights)\n  barplot(object$weights, names=asset.names,\n\t  xlab=\"Assets\", ylab=\"Weight\", main=\"Portfolio Weights\", ...)\n  invisible()\n}\n\n#\n# print method for Markowitz object\nprint.Markowitz <- function(x, ...)\n{\n  cat(\"Call:\\n\")\n  print(x$call)\n  xx <- rbind(x$er,x$sd)\n  dimnames(xx)[[1]] <- c(\"ER\",\"SD\")\n  cat(\"\\nFrontier portfolios' expected returns and standard deviations\\n\")\n  print(round(xx,4), ...)\n  invisible(x)\n}\n# hard-coded 4, should let user control\n\n#\n# summary method for Markowitz object\nsummary.Markowitz <- function(object, risk.free=NULL)\n{\n  call <- object$call\n  asset.names <- colnames(object$weights)\n  port.names <- rownames(object$weights)\n  if(!is.null(risk.free)) {\n    # compute efficient portfolios with a risk-free asset\n    nport <- length(object$er)\n    sd.max <- object$sd[1]\n    sd.e <- seq(from=0,to=sd.max,length=nport)\t\n    names(sd.e) <- port.names\n\n    #\n    # get original er and cov.mat data from call \n    er <- eval(object$call$er)\n    cov.mat <- eval(object$call$cov.mat)\n\n    #\n    # compute tangency portfolio\n    tan.port <- tangency.portfolio(er,cov.mat,risk.free)\n    x.t <- sd.e/tan.port$sd\t\t# weights in tangency port\n    rf <- 1 - x.t\t\t\t# weights in t-bills\n    er.e <- risk.free + x.t*(tan.port$er - risk.free)\n    names(er.e) <- port.names\n    we.mat <- x.t %o% tan.port$weights\t# rows are efficient portfolios\n    dimnames(we.mat) <- list(port.names, asset.names)\n    we.mat <- cbind(rf,we.mat) \n  }\n  else {\n    er.e <- object$er\n    sd.e <- object$sd\n    we.mat <- object$weights\n  }\n  ans <- list(\"call\" = call,\n\t      \"er\"=er.e,\n\t      \"sd\"=sd.e,\n\t      \"weights\"=we.mat)\n  class(ans) <- \"summary.Markowitz\"\t\n  ans\n}\n\nprint.summary.Markowitz <- function(x, ...)\n{\n\txx <- rbind(x$er,x$sd)\n\tport.names <- names(x$er)\n\tasset.names <- colnames(x$weights)\n\tdimnames(xx)[[1]] <- c(\"ER\",\"SD\")\n\tcat(\"Frontier portfolios' expected returns and standard deviations\\n\")\n\tprint(round(xx,4), ...)\n\tcat(\"\\nPortfolio weights:\\n\")\n\tprint(round(x$weights,4), ...)\n\tinvisible(x)\n}\n# hard-coded 4, should let user control\n\n#\n# plot efficient frontier\n#\n# things to add: plot original assets with names\n# tangency portfolio\n# global min portfolio\n# risk free asset and line connecting rf to tangency portfolio\n#\nplot.Markowitz <- function(object, plot.assets=FALSE, ...)\n# plot.assets\t\tlogical. If true then plot asset sd and er\n{\n  if (!plot.assets) {\n     y.lim=c(0,max(object$er))\n     x.lim=c(0,max(object$sd))\n     plot(object$sd,object$er,type=\"b\",xlim=x.lim, ylim=y.lim,\n          xlab=\"Portfolio SD\", ylab=\"Portfolio ER\", \n          main=\"Efficient Frontier\", ...)\n     }\n  else {\n\t  call = object$call\n\t  mu.vals = eval(call$er)\n\t  sd.vals = sqrt( diag( eval(call$cov.mat) ) )\n\t  y.lim = range(c(0,mu.vals,object$er))\n\t  x.lim = range(c(0,sd.vals,object$sd))\n\t  plot(object$sd,object$er,type=\"b\", xlim=x.lim, ylim=y.lim,\n          xlab=\"Portfolio SD\", ylab=\"Portfolio ER\", \n          main=\"Efficient Frontier\", ...)\n        text(sd.vals, mu.vals, labels=names(mu.vals))\n  }\n  invisible()\n}\n",
    "created" : 1458854189105.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "86806365",
    "id" : "855D6974",
    "lastKnownWriteTime" : 1367709296,
    "last_content_update" : 1367709296,
    "path" : "~/Intro_to_Computational_Finance/Week8/R_Assignment/portfolio.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}