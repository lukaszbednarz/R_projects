{
    "collab_server" : "",
    "contents" : "# printTransactions.r\n# \n# Function for HackerRank https://www.hackerrank.com/challenges/stockprediction challenge\n# last updated: March 24 2016 Lukasz Bednarz\n#\n# Functions:\n#\t1. printTransactions  \t\t\ttakes a float m money left, an integer k number of stocks, \n#                             an integer d days left, a string array name of stock names, \n#                             an integer array owned of stocks owned, and an 2d integer \n#                             array prices of stock prices containing k arrays of length 5 \n#                             and print your output.\n#\n\nprintTransactions <-\nfunction(m, k, d , name, owned, prices) {\n  portfolio<-list(\"m\" = m,\n                  \"k\" = k,\n                  \"d\" = d,\n                  \"name\" = name,\n                  \"owned\" = owned,\n                  \"prices\" = prices)\n  \n  #call<- match.call()\n  \n  # read back from storage file\n  if (file.exists('hist_prices.csv')){\n    Data <- read.csv('hist_prices.csv')\n    Data <- rbind(Data, portfolio$prices[,ncol(portfolio$prices)])\n    write.csv(Data, 'hist_prices.csv', row.names = FALSE)\n  }\n  else {\n    Data <- data.frame(t(prices))\n    names(Data)<-name\n    rownames(Data) <- c(1:nrow(Data))\n    write.csv(Data, 'hist_prices.csv',row.names = FALSE)\n  }\n  \n\n  portfolio.new<-optimizePortfolio(Data, portfolio)\n  \n  result<-prepareOutput(portfolio, portfolio.new)\n  \n  writeLines(result)\n  \n  result\n}\n\n###################\n# prepareOutput(portfolio.old, portfolio.new)\n###################\n\nprepareOutput <-\nfunction(old_p, new_p) {\n  \n  delta<-new_p$owned - old_p$owned\n  \n  orders<-new_p$name[delta != 0]\n  \n  outp<-paste0(length(orders),\"\\n\",collapse=\"\")\n  \n  for (tick in orders) {\n    cmd<-\"BUY\"\n    if (delta[tick] < 0){\n      cmd<-\"SELL\"\n    }\n    outp<-paste0(outp,paste(tick, cmd, abs(delta[tick]) ), \"\\n\", collapse=\"\")\n  }\n  \n  outp\n}\n\noptimizePortfolio <-\nfunction (data, portf) {\n  \n  ### Calculate covariance matrix\n\n  stox.df.logd <- log(data[2:nrow(data),]) - log(data[1:nrow(data)-1,])\n  \n  stox.ret<-colMeans(stox.df.logd)\n  target.ret = max(stox.ret)\n  \n  stox.cov<-cov(stox.df)\n  \n  price.current<-data[nrow(data),]\n  \n  # calculate current portfolio value of holdings\n  w.current <- portfolio$owned*price.current\n  \n  # total portfolio value\n  net.portf <- sum(w.current)\n  \n  w.current <- w.current/(net.portf + portf$m)\n\n  # computing efficient portfolio\n  w <- efficientPortfolio(stox.cov, stox.ret, price.current, portf$owned, portf$m, portf$name )\n  \n  #  trades in terms of number of shares\n  delta <- round((w - w.current)*(net.portf+portf$m)/price.current,0)\n  \n  # action\n  \n  portf.new <- portf\n  \n  portf.new$owned <- portf$owned + delta\n  \n  portf.new\n}\n\nefficientPortfolio <-\nfunction(stox.cov, stox.ret, prices, owned, cash, stox.names ){\n  \n  library(quadprog)\n  # As there is no shorts\n  # this is QP problem: min(-d' b + 1/2 b' D b) with the constraints A' b >= b_0.\n  # in our case A consist of rules: weights'*returns = alpha_0 weights > = zeros(mx1)\n  # weights'*ones(mx1) = 1\n  # solve.QP(Dmat, dvec, Amat, bvec, meq=0, factorized=FALSE)\n  net.holdings <- owned*prices\n  net.holdings.total <- sum(net.holdings)\n  net.assets.total <- net.holdings.total + cash\n  \n  # maximum total of shares in portfolio\n  stox.allocation <- 0.7\n  \n  N_stock <- nrow(stox.cov)\n  \n  # risk premium range for sharpe optimalization\n  risk.prem <- seq(0, 2, 0.1)\n  \n  \n  # maximum alocations for stocks\n  alloc.max <- as.numeric(rep(0,N_stock))\n  \n  ## the weights have to be less than weight of max integer number of shares\n  ## that can be used for given portfolio net value some stock cannot be bought because they\n  ## are more expensive than whole net assets or available cash\n  for (ii in 1:N_stock) {\n    if (net.assets.total > 0) {\n      alloc <- min(net.holdings[ii]/(net.assets.total ) + floor(cash/prices[ii])*prices[ii]/net.assets.total, stox.allocation)\n      alloc <- floor(alloc*(net.assets.total )/prices[ii])*prices[ii]/(net.assets.total)\n    }\n    else {\n      alloc <- floor(stox.allocation*cash/prices[ii])*prices[ii]/cash\n    }\n    \n    alloc.max[ii] <- alloc\n  }\n  \n  # sellect stocks for efficient portfolio \n  alloc.max.num.shares <- round(as.numeric(alloc.max)*net.assets.total/prices)\n  stox.eff.ix <- c(1:N_stock)[alloc.max.num.shares > 0]\n  stox.names.eff <- stox.names[stox.eff.ix]\n  prices.eff <- prices[stox.eff.ix]\n  stox.ret.eff <- stox.ret[stox.eff.ix]\n  stox.cov.eff <- stox.cov[stox.eff.ix, stox.eff.ix]\n  alloc.max.eff <- alloc.max[stox.eff.ix]\n  \n  # number of stock selected for optimization\n  N_eff <- length(stox.eff.ix)\n  \n  w.opt <- alloc.max\n  \n  # optimize only if more than one stock can be bought/is hold\n  if (N_eff > 1 & sum(as.numeric(alloc.max.eff)) > stox.allocation) {\n    \n   \n    \n    # reduced covariance matrix\n    Dmat <- 2*stox.cov.eff\n    \n    # conditions for equality\n    bvec.eq <- stox.allocation # we want to keep 30% of cash free for liquidity\n    Amat.eq <- rep(1, length(N_eff))\n    \n    # number of equality conditions\n    meq <- 1\n    \n    # conditions for inequality (range of assets weights)\n    bvec.ineq.low <- as.numeric(rep(0, N_eff))\n    bvec.ineq.max <- -as.numeric(alloc.max.eff)\n    bvec.ineq <- c(bvec.ineq.low, bvec.ineq.max)\n    \n    Amat.ineq.low <- diag(N_eff)\n    Amat.ineq.max <- -diag(N_eff)\n    \n    Amat.ineq <- cbind(Amat.ineq.low, Amat.ineq.max)\n    \n    \n    eff <- matrix(nrow = length(risk.prem), ncol = N_eff + 3)\n    colnames(eff) <- c(stox.names.eff,\"Std.Dev\",\"Exp.Return\",\"Sharpe\")\n    \n    sharpe.max <- 0\n    prem.max <- 1\n    loop.max <- 1\n    loop <- 1\n    \n    \n    # find approximate efficient portfolio with max sharpe\n    for (ii in 1:length(risk.prem)) {\n    \n      dvec <- stox.ret.eff*risk.prem[ii]\n      Amat <- cbind(Amat.eq, Amat.ineq)\n      bvec <- c(bvec.eq, bvec.ineq)\n    \n      result <- solve.QP(Dmat = Dmat,dvec = dvec,Amat = Amat,bvec = bvec,meq = meq)\n      eff[loop,\"Std.Dev\"] <- sqrt(sum(result$solution *colSums((stox.cov.eff * result$solution))))\n      eff[loop,\"Exp.Return\"] <- as.numeric(result$solution %*% stox.ret.eff)\n      eff[loop,\"Sharpe\"] <- eff[loop,\"Exp.Return\"] / eff[loop,\"Std.Dev\"]\n      eff[loop,1:N_eff] <- result$solution\n      \n      if (eff[loop,\"Sharpe\"] > sharpe.max) {\n        sharpe.max <- eff[loop,\"Sharpe\"]\n        prem.max <- risk.prem[ii]\n        loop.max <- ii\n      }\n      # increment loop counter\n      loop <- loop + 1\n      \n    }\n    \n    # reduced eff portfolio weights\n    w.sharpe.eff <- eff[loop.max,1:N_eff]\n    \n    # full portfolio weights\n    w.sharpe <- rep(0,N_stock)\n    w.sharpe[stox.eff.ix] <- w.sharpe.eff\n    \n    \n    # sorting prices in decreasing order\n    prices.sorted <- sort(as.numeric(prices[stox.eff.ix]), index.return = TRUE, decreasing = TRUE)\n    prices.sorted.ix <- prices.sorted$ix\n    # vector fixing stock values starting from most expensive\n    # then continuing optimizing portfolio down to least expensive\n    b.eq <- as.numeric(alloc.max)\n    \n    opt <- matrix(nrow = length(prices.sorted.ix) - 1, ncol = N_eff + 3)\n    colnames(opt) <- c(stox.names.eff,\"Std.Dev\",\"Exp.Return\",\"Sharpe\")\n    loop <- 1\n    \n    budget <- stox.allocation\n    \n    while (loop < length(prices.sorted.ix)) {\n      ii <- prices.sorted.ix[loop]\n      meq <- meq + 1\n      # vector for stock beeing fixed in Amat\n      Amat.vec <- rep(0,N_eff)\n      Amat.vec[ii] <- 1\n      Amat.eq <- cbind(Amat.eq, Amat.vec)\n      \n      # filling the available budget starting from most expensive asset\n      b.eq[ii] <- min(floor(net.assets.total*budget/prices.eff[ii])*prices.eff[ii]/net.assets.total,\n                    round(net.assets.total/prices.eff[ii]*w.sharpe.eff[ii]))\n      bvec.eq <- c(bvec.eq, b.eq[ii])\n      # adjusting remaining allocation budget\n      budget <- budget - b.eq[ii]\n      \n      if (sum(as.numeric(b.eq) >=  stox.allocation)) {\n      dvec <- stox.ret.eff*risk.prem[loop.max]\n      \n        # removing inequality condition for fixed assets\n        bvec.ineq.opt.low <- bvec.ineq.low[-c(prices.sorted.ix[0:loop])]\n        bvec.ineq.opt.max <- bvec.ineq.max[-c(prices.sorted.ix[0:loop])]\n        bvec <- c(bvec.eq,bvec.ineq.opt.low, bvec.ineq.opt.max)\n        \n        Amat.ineq.opt.low <- Amat.ineq.low[,-c(prices.sorted.ix[0:loop])]\n        Amat.ineq.opt.max <- Amat.ineq.max[,-c(prices.sorted.ix[0:loop])]\n        Amat <- cbind(Amat.eq, Amat.ineq.opt.low, Amat.ineq.opt.max)\n        \n        # solving QR problem\n        result <- solve.QP(Dmat = Dmat,dvec = dvec,Amat = Amat,bvec = bvec, meq = meq)\n      }\n      else {\n        result$solution[-c(prices.sorted.ix[0:loop])] <- 0\n         \n      }\n      \n      opt[loop,\"Std.Dev\"] <- sqrt(sum(result$solution *colSums((stox.cov.eff * result$solution))))\n      opt[loop,\"Exp.Return\"] <- as.numeric(result$solution %*% stox.ret.eff)\n      opt[loop,\"Sharpe\"] <- eff[loop,\"Exp.Return\"] / eff[loop,\"Std.Dev\"]\n      opt[loop,1:N_eff] <- result$solution\n      \n      # increment loop\n      loop <- loop + 1\n    }\n  \n    \n    w.opt <- w.sharpe\n    w.opt[stox.eff.ix] <- result$solution\n  }\n  \n  # return optimized solution.\n  w.opt\n  \n}\n",
    "created" : 1459046146896.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3072629925",
    "id" : "65957C92",
    "lastKnownWriteTime" : 1459050394,
    "last_content_update" : 1459050394169,
    "path" : "~/Lukasz/Learning/HackerRank_R/02_Stock_Predictions/printTransactions.r",
    "project_path" : "printTransactions.r",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}